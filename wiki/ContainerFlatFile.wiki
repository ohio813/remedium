#summary Discuss, document and implement the Flat file container

= Introduction =

A flat file container is a remedium class that is used for storing and retrieving data using flat files. It is necessary since the current HSQL implementation of the container is using an excessive amount of RAM.


There exist trade-offs about this approach:
  * When the file name becomes long then it is unreadable by humans
  * File contents might changes and differ from what is reported on the file name
  * This structure is limited to a single level of key-value pairs. Typical INI methods allow using INI sections
  * Some Operative Systems such as Windows will limit the max size of the file name to 256 characters
  * Malicious actors can tamper the file name or file contents
  * Additional time required to process records
  * Not a mature technique, will be prune to errors

And advantages:
  * Third-party providers can supply additional knowledge bases
  * End users can manage available knowledge by their own means
  * Reduced RAM usage
  * Expand supported storage to large scale management on normal workstations

The main driver to adopt flat files is the need to find a solution that avoids an excessive RAM consumption.

----

= Desired properties =

  * Allows to set the max number of records per data file
  * Least amount possible of data files
  * Quick to retrieve data
    * Should read a record from a DB with 100 000 records under an average of 0,05 seconds after 100 random record reads
  * Quick to store data
    * Should write onto a DB 100 000 records under 10 minutes
  * Scale up to millions of records
    * Should write a DB with 100 000 000 records and manage them
  * Memory efficient
    * Overall memory usage shouldn't surpass 30Mb regardless of DB size

----

= Nice to haves =

We can attempt to store a max of a million of records for each file, however, it would be particularly nice to allow other providers to add more data on a folder.

For example, we create a knowledge container with information gathered by someone about Microsoft Windows files and we include this knowledge inside our own container in a decentralized manner.

The big advantage is allowing providers to make available specialized knowledge about a given subject. 

People interested in updating the knowledge of their containers can do so manually. Despite primitive, it does bring the advantage of letting end-users manage updates and get them from other providers of their preference.


For this model of data exchange be possible, we can't enforce a specific folder structure but rather scan all files and subfolders to discover the type of information that each container is providing.



----

= Development approach =

I have recently implemented the Container Dump class that is basically dumping all records from an HSQL database onto flat files. The remarkable speed noted when importing and exporting these records are the main reason why this class is now being implemented.

Some of the code and lessons learned from the implementation of Container dump can now be applied to this new class. The page section "Desired properties" is a guideline of performance requirements on my development machine (Toshiba R-630 laptop, i5 CPU x64 with 4Gb of RAM under Windows 7). 

A test case is being developed along case with this class implementation to ensure that each method and step of this process is tested using a repetitive approach.

=== Identifying files with knowledge ===

Since under this model all files will be mixed and use a unknown folder structure, we are left with the challenge of identifying the contents of a given knowledge base flat file. We need to do this without reading the contents otherwise this method would become prohibitive to use when these files are numerous and large sized. 

To identify each file, we apply the concept of file name properties that was introduced with the Container Dump class where we add an identifier to the file name. We scan all files inside a given folder and subfolder

This way we scan files very quickly and in the process get file names that contain information about their respective contents.

File name information uses Key=Value approach as seen for INI files with no INI sections. There are two reserved characters:
  * {{{-}}} is equivalent to "="
  * {{{_}}} separates key-value pairs from each others

An example of this usage: 
{{{db-crc32_since-1309513994973_until-1309514033984_count-2307_checksum-6970388375f06a91f9b8f133697f94f2a1e0ed54ec1d64cebfb47f43595712bd_v-1.txt}}}
Note how we see different key-value pairs that allow extracting information from the file without needing to read the contents. 


----

= How it works =

We created an Interface class to the Container and this way it is possible to create implementation of the container using more technologies in the future other than just HSQL or Flat files.

Over the next sections we detail the important steps for this class that intend to serve as a guideline for implementation and later serve as documentation for the class itself.

=== Glossary ===

This section provides a quick overlook of the meaning and context of terms used over this chapter.

  * *target folder* - the folder where where the containers are stored
  * *container ID* - unique ID text that identifies the type of knowledge (example: crc32, sha1, ...)
  * *knowledge file* - flat file where data records are stored
  * *index file* - a file placed at the root of the target folder that contains the location and resources provided by each of knowledge file that was found

=== Steps of initialization ===

  * Find knowledge files inside the target folder, crawl subfolders
  * Create an index file for our container ID if one does not exist
  * Get the knowledge files that match our container ID
  * Sort these files according to their importance level. Higher number = higher importance = first to be processed
  * We save time if there have been no changes since the last start, so we check if there have been changes
    * Check if the knowledge file is mentioned on the index file
      * In case the knowledge file is mentioned, verify details such as check-sum of the file and date of last modification to check if any changes occurred
      * If nothing changed, no need to read the knowledge file
      * Otherwise, proceed with reading of knowledge
  * For each knowledge file, evaluate the following properties:
    * File name describes this file as read-only or read-write?
    * Compute current check-sum of knowledge file
    * Get absolute file path and date of last modification
    * Get the number of records present in file
    * Verify if the number of columns on each record matches our expected size
  * Write the properties about each knowledge file on the index file, according to their order of importance
  * From the processed knowledge files, create a list of files that will accept new records to be added
    * If no knowledge files are available to add new records, create a new knowledge file and mark it as available
  * Done!



== Constructor ==

The first step is invoking the constructor method:
{{{container = new ContainerFlatFile(id, fields, rootFolder, result);}}}

Where:
  * String *id* is the identification name of this container
  * String[] *fields* are the columns for our table 
  * File *rootFolder* is the folder where we are storing the containers 
  * LogMessage *result* is a log message object that contains details about this operation

 
=== Initial checks ===

We first care to ensure that our *root folder* is valid and then we will check if we can create a sub folder with the same name as *id*.

If anything goes wrong, the *result* message will provide details and a specific value number under {{{result.getCode()}}} that you can use for debugging what has happened. 

At this moment, there are no checks to verify if there exists enough disk space for storing data records in a reasonable manner (at least 200Mb available).


----


= Progress =

30th June 2011
  * Initial implementation of new class
  * Introduced concept of log message object to allow testing the new class without tying it on a remedium component (allows testing exclusively the new class without interference from components)
1st July 2011
  * Documentation and progress added on google code