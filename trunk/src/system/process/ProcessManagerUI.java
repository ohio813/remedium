/*
 * The component is intended to control the User Interface, along with
 * receiving and dispatching messages from other processes.
 */

package system.process;

import system.core.Component;
import java.util.ArrayList;
import java.util.Hashtable;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;
import org.simpleframework.http.Request;
import org.simpleframework.http.Response;
import remedium.Remedium;

/**
 *
 * @author Nuno Brito, 4th of April 2011 in Germany.
 */
public class ProcessManagerUI extends javax.swing.JFrame {

    private Boolean
            isRunning = false;
    private Remedium
            instance;
    private long
            remLock;
    private Hashtable
            list = new Hashtable();
    private String
            rootNode = "Applications";
    private UIcomp
            comp;

    /** Creates new form ProcessManagerUI */
    public ProcessManagerUI() {
        initComponents();
    }

    public ProcessManagerUI(Remedium instance, long assignedRemLock) {
        this.doConstructor(instance, assignedRemLock);
    }

    private void doConstructor(Remedium assignedInstance,
            long assignedRemLock){

        // preflight checks
        if(assignedInstance == null){
            System.out.println("ProcessManagerUI Constructor has failed."
                    + " Can't use a null instance");
            return;
        }

        // assign our own instance to the one provided
        instance = assignedInstance;
        // do the same for remLock
        remLock = assignedRemLock;

        isRunning = true;

    // Adopt the defaul system look for our window
          try {
            try {
                UIManager.setLookAndFeel
                        (UIManager.getSystemLookAndFeelClassName());
            } catch (ClassNotFoundException ex) {
            } catch (InstantiationException ex) {
            } catch (IllegalAccessException ex) {
            }
            } catch (UnsupportedLookAndFeelException ex) {
                }

          setLocationRelativeTo(null);
          pack();

         initComponents();

          // only allow selecting one node on the JTree component
          treeProcess.getSelectionModel()
                  .setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);

          // hide the progress bar
          updateProgress(false,-1);
          // disable our buttons
          updateButtons(false,false,-1);

       
//        try {
//            jEditorPane1.setPage("http://localhost:10101/file");
//        } catch (IOException ex) {
//            Logger.getLogger(ProcessManagerUI.class.getName()).log(Level.SEVERE, null, ex);
//        }

         java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                // make the form visible
                setVisible(true);
            }
        });

        // kick off our GUI
        this.doStart();
        
           // html.setText("<html><b><u>T</u>wo</b><br>lines</html>");


    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonStop = new javax.swing.JButton();
        buttonPause = new javax.swing.JButton();
        progressBar = new javax.swing.JProgressBar();
        jScrollPane2 = new javax.swing.JScrollPane();
        treeProcess = new javax.swing.JTree();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setLocationByPlatform(true);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                closingWindow(evt);
            }
        });

        buttonStop.setText("Stop");

        buttonPause.setText("Pause");

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("System");
        javax.swing.tree.DefaultMutableTreeNode treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("Civis");
        javax.swing.tree.DefaultMutableTreeNode treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("analyzer");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("scanner");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("GUI");
        treeNode2.add(treeNode3);
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("Centrum");
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("progress");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("status");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("operation");
        treeNode2.add(treeNode3);
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("Triumvir");
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("progress");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("status");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("operation");
        treeNode2.add(treeNode3);
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("Quaestor");
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("progress");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("status");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("operation");
        treeNode2.add(treeNode3);
        treeNode1.add(treeNode2);
        treeNode2 = new javax.swing.tree.DefaultMutableTreeNode("Components");
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("database");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("network");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("message_queue");
        treeNode2.add(treeNode3);
        treeNode3 = new javax.swing.tree.DefaultMutableTreeNode("process_manager");
        treeNode2.add(treeNode3);
        treeNode1.add(treeNode2);
        treeProcess.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        treeProcess.setRowHeight(19);
        treeProcess.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                treeProcessMouseClicked(evt);
            }
        });
        jScrollPane2.setViewportView(treeProcess);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 152, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(buttonPause)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(buttonStop))
                    .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 166, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(buttonStop, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(buttonPause, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void closingWindow(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_closingWindow
       /** When closing the window, end our execution */
        isRunning = false;
       // System.out.println("Window closed");
    }//GEN-LAST:event_closingWindow

    /**
     * Look on the process tree and return the name of the selected item.
     */
    private String getTreeSelected(){
        String result = null;
          // the mouse was clicked inside the tree box
        TreePath selected = treeProcess.getSelectionPath();

        if(selected == null)
            return "";
        // get our tree node
        DefaultMutableTreeNode node =
           (DefaultMutableTreeNode)selected.getLastPathComponent();

        if(node==null)
            return "";
        // get the object refering to the parent node
        TreePath selectedParent = selected.getParentPath();

        if(selectedParent == null)
            return "";
        // get the parent node
        DefaultMutableTreeNode nodeParent =
           (DefaultMutableTreeNode)selectedParent.getLastPathComponent();

        // we have selected the root node if the value is null, we don't need it
        if(nodeParent == null)
            return "";
        // show the status of this process on the user interface
        result = nodeParent.toString()+"/"+node.toString();
    return result;
    }

    /** set the currently selected node on the tree view */
    private void setTreeSelected(String who){
        // preflight checks
        if(who == null)
            return;
        if(who.length()==0)
            return;

        // we assume that the tree view is already populated

        // split this into several name components
     String name = who;
//     String App = name.substring(0, name.indexOf("/") );
//     String Role = name.substring(name.indexOf("/") +1,name.length());

     // first step, iterate throught all the ones that match our role name

     // get the tree object
     DefaultTreeModel model = (DefaultTreeModel) treeProcess.getModel();
     model.getRoot();

     // get our tree node
        DefaultMutableTreeNode node =
           (DefaultMutableTreeNode) model.getRoot();


        System.out.println
                ("------->"+node.getChildCount());


    }

    /** This code grabs the text from the selected node and from its
     *  parent.
     */
    private void treeProcessMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_treeProcessMouseClicked
        // show the status of the selected process on the user interface
        showStatus(getTreeSelected());
    }//GEN-LAST:event_treeProcessMouseClicked


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonPause;
    private javax.swing.JButton buttonStop;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JTree treeProcess;
    // End of variables declaration//GEN-END:variables

    
    /** check if we are running or not */
    public Boolean isRunning() {
        return isRunning;
    }


    /** update the display tree with the process list */
    public boolean updateTree(){

    // get all the running processes
    ArrayList<Status> results = instance.getProcess().getList();

    // get the node currently selected
    String previouslySelected = getTreeSelected();

    // clear all our previous results
    list.clear();

    DefaultMutableTreeNode parent = 
            new DefaultMutableTreeNode(rootNode, true);


    for(Status process : results){

        // split between the parent app and the child role
     String name = process.getName();

     String App;
     String Role;

     // get the separator between applications and roles
     int i = name.indexOf("/");

     if(i >= 0){ // if there is one, get the application name
         App = name.substring(0, i );
         Role = name.substring(i + 1,name.length());
        }
     else { // or else it is empty, we use the string as the role name
         App = name;
         Role = "";
        }


     // where we have the Application node
      DefaultMutableTreeNode nodeApp;
      
     // if the app node is not listed, create one
     if(list.containsKey(App)==false){
        nodeApp = new DefaultMutableTreeNode(App);
        // put this on our list
        list.put(App, nodeApp);
        // put this on our root node
        parent.add(nodeApp);
     }
     else // just grab the node from our list if it exists
        nodeApp = (DefaultMutableTreeNode) list.get(App);


      // now do the same for the Role/Secondary node
      DefaultMutableTreeNode nodeRole;

      if(list.containsKey(name)==false){
        nodeRole = new DefaultMutableTreeNode(Role);
        list.put(name, nodeRole);
      }
      else // just grab the node that we have with this name
        nodeRole = (DefaultMutableTreeNode) list.get(name);

      // add the role onto the app
      if(Role.length()>0) // only if the role isn't empty
        nodeApp.add(nodeRole);
    }

    // change the jTree to reflect our changes
     DefaultTreeModel model = (DefaultTreeModel) treeProcess.getModel();
     model.setRoot(parent);
     /** good example of jTree usage:
      * http://www.roseindia.net/java/example/java/swing/AddNodes.shtml
      */
    // System.out.println("Updated");

     // selected back the previously selected one
     setTreeSelected(previouslySelected);
     
     return true;
    }


    /** Show the status of a given process on the User Interface */
    private void showStatus(String who){
        //preflight checks
        // ignore this method in case we are not a role/secondary process
        if(who.contains(rootNode))
            return;



        // get the status of this process
        Status status = instance.getProcess().getStatus(who);

        if(status==null)
            return; // no status, no kiss

        long uptime = System.currentTimeMillis() - status.getCreated();
        String uptimeText = utils.time.timeNumberToHumanReadable(uptime);

        long updated = System.currentTimeMillis() - status.getUpdated();
        String updatedText = utils.time.timeNumberToHumanReadable(updated);


        // let's display the status on text area
//        String result =
//                "<html><body>" +
//                ""+status.getName()
//                +" ("
//                + ""+utils.text.translateStatus(status.getStatus())
//                +")<br><br>"
//                +"<b>Uptime</b> of "+uptimeText
//                +"<br>"
//                +"<b>Updated</b> "+updatedText + " ago"
//
//                +"</body></html>"
//                    ;
        // place this text on the user interface
        //areaStatus.setText(result);
        //html.setText(result);
    }

    /** Modify our progress bar. If the progress value is below zero
     * then it is hidden.
     * @since 110405
     */
    private void updateProgress(Boolean indeterminate, int progress){

        progressBar.setIndeterminate(indeterminate);

        if(progress<0)
            progressBar.setVisible(false);
        else{
            progressBar.setVisible(true);
            progressBar.setMaximum(100);
            progressBar.setMinimum(0);
            progressBar.setValue(progress);
        }

    }

    /** update our UI buttons */
    private void updateButtons(boolean stop, boolean pause, int progress) {
        buttonStop.setEnabled(stop);
        buttonPause.setEnabled(pause);
    }


  

    /** do the doStart to set up our User Interface as intended */
    private void doStart(){
        // create the component that is registered on the system
       comp = new UIcomp(instance,remLock, this);
        // update our tree
        updateTree();
    }



}


 class UIcomp extends Component {

     public UIcomp(Remedium assignedInstance,
            long assignedRemLock,
            ProcessManagerUI assignedUI){
        // call the super component!!
         super(assignedInstance);

          UI = assignedUI;

     }

    ProcessManagerUI UI;

            /** set the UI that we can control */
            public void setUI(ProcessManagerUI assignedUI){
                UI = assignedUI;
            }

            @Override
            public void onStart() { // check if the onStart is working

                // we don't need to update ourselves very often
                this.setTime(4);

                log(ROUTINE,"Process Manager UI is available");
                return;
            }

            @Override
            public void onLoop() {
               // log(DEBUG,"Looping");
                if(UI!=null){
                    UI.updateTree();
                }
            }

            @Override
            public void onStop() {
                log(ROUTINE,"Stopping");
            }

            @Override
            public void onRecover() {
               log(DEBUG,"Recovering my world!");
            }

            @Override
            public String getTitle() {
                return "UI";
            }

    @Override
    public String doWebResponse(Request request, Response response) {
                return getTitle();
    }


 }